package org.atzberger.mango.atz3d;

import org.atzberger.mango.atz3d.Atz_LinearAlgebra;
import org.atzberger.mango.atz3d.Atz3D_Camera;
import org.atzberger.mango.atz3d.Atz3D_Renderer_SELM;
import org.atzberger.mango.atz3d.Atz3D_Model;
import java.awt.Color;
import java.awt.Composite;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.GradientPaint;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.event.MouseWheelEvent;
import java.awt.event.MouseWheelListener;
import java.awt.geom.Ellipse2D;
import javax.swing.JPanel;
import org.atzberger.application.selm_builder.SELM_InteractionRenderView;
import org.atzberger.application.selm_builder.SELM_RenderView;

/**
 *
 * Interface panel to display the render view.   Provides ability to rotate the
 * camera view and zoom.
 *
 * @author Paul J. Atzberger
 *
 * @see <a href="http://www.atzberger.org">http://www.atzberger.org</a>
 */
public class JPanel_Model_View_RenderPanel extends javax.swing.JPanel
                                               implements MouseListener, MouseMotionListener, MouseWheelListener {

  public final static int interfaceMode_Null             = 0;
  public final static int interfaceMode_External_Control = 1;
  public final static int interfaceMode_Navigation       = 2;
  public final static int interfaceMode_Move             = 3;
  public final static int interfaceMode_Zoom             = 4;
  
  //JPanel        jPanel_Display                     = null;

  //JPopupMenu jPopupMenu = null;
  public Atz3D_Camera camera = null;
  public Atz3D_Camera camera_on_click = null;
  public Atz3D_Model model3D = null;
  public Atz3D_Renderer_SELM atz3D_Renderer_SELM = null;
  public int flagInterfaceMode = interfaceMode_Null;
  protected SELM_InteractionRenderView[] interactionRenderList = new SELM_InteractionRenderView[0];
  protected SELM_RenderView[] renderViewList = new SELM_RenderView[0];
  
  public int flagMouseDraggedOn = 0;
  public double mouseClickedPositionX;
  public double mouseClickedPositionY;
  public double mousePositionOnClickX;
  public double mousePositionOnClickY;
  public double mouseClickedPositionX_last;
  public double mouseClickedPositionY_last;
  long mouseClickedElaspedTime;
  long mouseClickedElaspedTime_last;

  Color backgroundColor1 = Color.WHITE;
  Color backgroundColor2 = Color.WHITE;
  
  /** Creates new form JPanel_Model_View_RenderPanel */
  public JPanel_Model_View_RenderPanel() {
    initComponents();

    this.addMouseListener(this); /* listens to itself */
    this.addMouseMotionListener(this); /* listens to itself */
    this.addMouseWheelListener(this); /* listens to itself */

    /* setup default view for the camera */
    camera = new Atz3D_Camera();

    /* setup default model */
    model3D = new Atz3D_Model();

    /* setup renderer */
    atz3D_Renderer_SELM = new Atz3D_Renderer_SELM();
    
  }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setName("Form"); // NOI18N

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables


  /** Resets the camera to default view */
  public void resetCameraView() {
    camera.setDefaultValues();

    //super.setSize(this.getRenderScreenSize()); /* @@@ PJA */

  }

  //public void setDisplayPanel(javax.swing.JPanel refPanel) {
    // jPanel_Display = refPanel;
  //}

  //public void setPopupMenu(javax.swing.JPopupMenu refPopupMenu) {
  //  jPopupMenu = refPopupMenu;
  //}

  /** Sets the state of the interface controls */
  public void setInterfaceMode(int mode) {
    flagInterfaceMode = mode;
  }

  /** Paint the render view */
  public void paint(Graphics g) {
    //paint_old_way(g);
    //paint_new_way(g);
    paint_new_new_way(g);

  }

  /** Rebuilds the entire model to be rendered */
  public void rebuildEntireModel() {

    /* calls each of the objects which have elements
     * represented in the render pane and asks them to
     * reconstruct their elements.  The calling order
     * is as follows:
     *
     * Lagrangian Structures
     * Eulerian Structures
     * Coupling Operators
     * Interactions
     *
     */



  }


  /** Rebuilds the entire model to be rendered */
  public void rebuildModelComponent() {

  }


  /** Paints the display */
  public void paint_new_way(Graphics g) {

    /* render the model given the current camera location */
    atz3D_Renderer_SELM.render((JPanel) this, g, model3D, camera);

    /* -- Plot the interactions (as addition, may change in future) */
    //plotInteractions(g);

  }

  /** Paints the display */
  public void paint_new_new_way(Graphics g) {

    model3D = new Atz3D_Model();

    renderViewsToModel3D(model3D);

    /* render the model given the current camera location */
    atz3D_Renderer_SELM.render((JPanel) this, g, model3D, camera, backgroundColor1, backgroundColor2);

  }

  /** Paints the display */
  public void syncCanvasSizeWithContainer() {

    /*
    if (jPanel_Display != null) {
      int w = jPanel_Display.getWidth();
      int h = jPanel_Display.getHeight();
      setBounds(1, 1, w - 1, h - 1);
      //setBounds(1, 1, w - 1, w - 1);
    }
     */
  }

  /** Generates a rotation matrix about the z-axis */
  public void genRotationMatrixZAxis(double theta, double matrix[]) {

    /* first row */
    matrix[0] = java.lang.Math.cos(theta);
    matrix[1] = java.lang.Math.sin(theta);
    matrix[2] = 0.0;

    /* second row */
    matrix[3] = -java.lang.Math.sin(theta);
    matrix[4] = java.lang.Math.cos(theta);
    matrix[5] = 0.0;

    /* third row */
    matrix[6] = 0;
    matrix[7] = 0;
    matrix[8] = 1.0;
  }


    public void paint_test1(Graphics g) {
        Graphics2D g2 = (Graphics2D) g;
        Dimension size = getRenderScreenSize();
        Composite origComposite;

        /*
        if (jPanel_Display != null) {
          int w     = jPanel_Display.getWidth();
          int h     = jPanel_Display.getHeight();
          setBounds(1, 1, w - 1, h - 1);
        }
         */

        Font font = new Font("Serif", Font.PLAIN, 36);
        g.setFont(font);

      /*
      int wText = (int) 0.2*size.width;
      int hText = (int) 0.2*size.height;
       */
      int wText = 100;
      int hText = 50;
      int rX = (size.width - wText) / 2;
      int rY = (size.height - hText) / 2;
      int w = size.width;
      int h = size.height;
      int r1, r2;
      int x, y;

      /*
      g.setColor(Color.GREEN);
      g2.fillRect(rX, rY, wText, hText);
       */

      g.setColor(Color.BLUE);
      g2.fillRect(0, 0, 10, 10);

      g.setColor(Color.RED);
      g2.fillRect(w - 10, h - 10, w, h);

      int k;
      int N;
      double R;
      double x0, y0;
      double xx, yy;
      double theta;

      Ellipse2D.Double circle[];
      GradientPaint p2[];

      r1 = 10;
      r2 = r1;

      x0 = (w / 2.0);
      y0 = (h / 2.0);

      R  = java.lang.Math.min(0.9*(w/2.0), 0.9*(h/2.0));

      N = 1000;
      circle = new Ellipse2D.Double[N];
      p2 = new GradientPaint[N];

      for (k = 0; k < N; k++) {

        theta = (k / (1.0*N)) * 2.0 * java.lang.Math.PI;

        xx = java.lang.Math.sin(theta);
        x = (int) ((R * xx) + x0 - (r1 / 2.0));

        yy = java.lang.Math.cos(theta);
        y = (int) ((R * yy) + y0 - (r2 / 2.0));

        circle[k] = new Ellipse2D.Double(x, y, r1, r1);

        /* gradient paint */
        //if (flagPlotFancyControlPts == 1) {
//          p2[k]     = new GradientPaint(x, y, Color.cyan, (int) (x + 1.5 * r1), (int) (y + 1.5 * r2), Color.black, false);
//          g2.setPaint(p2[k]);
//        } else {
//          g2.setPaint(Color.blue);
//        }

        g2.fill(circle[k]);


      }


        /*
        Point2D center = new Point2D.Float(50, 50);
        float radius = 25;
        Point2D focus = new Point2D.Float(40, 40);
        float[] dist = {0.0f, 0.2f, 1.0f};
        Color[] colors = {Color.RED, Color.WHITE, Color.BLUE};

        RadialGradientPaint p1 = new RadialGradientPaint(center, radius, focus,
                                                         dist, colors,
                                                         CycleMethod.NO_CYCLE);
         */


        /*
        g.setColor(Color.BLUE);
        g2.fillRect(x,y, 10,10);
*/

    } /* end paint() */




    void eventOutput(String eventDescription, MouseEvent e) {

    /*
        System.out.println(eventDescription
                + " (" + e.getX() + "," + e.getY() + ")"
                + " detected on "
                + e.getComponent().getClass().getName()
                );
    */

    }

    public void mousePressed(MouseEvent e) {
        eventOutput("Mouse pressed (# of clicks: "
                + e.getClickCount() + ")", e);

        //maybeShowPopup(e);

    }

    public void mouseReleased(MouseEvent e) {
        eventOutput("Mouse released (# of clicks: "
                + e.getClickCount() + ")", e);

        //maybeShowPopup(e);

      /* repaint the display */
      //jPanel_Display.repaint();
      repaint();

      flagMouseDraggedOn = 0;
    }

    public void mouseEntered(MouseEvent e) {
        eventOutput("Mouse entered", e);
    }

    public void mouseExited(MouseEvent e) {
        eventOutput("Mouse exited", e);
    }

    public void mouseClicked(MouseEvent e) {
        eventOutput("Mouse clicked (# of clicks: "
                + e.getClickCount() + ")", e);

      
        /*
        mouseClickedPositionX_last = mouseClickedPositionX;
        mouseClickedPositionY_last = mouseClickedPositionY;

        mouseClickedPositionX = e.getX();
        mouseClickedPositionY = e.getY();
         */

        /*
         *   public void mousePressed(MouseEvent e) {
    maybeShowPopup(e);
  }

  public void mouseReleased(MouseEvent e) {
    maybeShowPopup(e);
  }


         */
    }



  //private void maybeShowPopup(MouseEvent e) {

//    if (e.isPopupTrigger()) {
//      jPopupMenu.show(e.getComponent(),
//                      e.getX(), e.getY());
//    }

//  }


  public void mouseMoved(MouseEvent e) {

    //eventOutput("Mouse dragged", e);
    //eventOutput("Mouse moved", e);

  }


  public void mouseDragged(MouseEvent e) {

    if (flagInterfaceMode == interfaceMode_Navigation) {
      interface_Navigation_mouseDragged(e);
    }
    
    if (flagInterfaceMode == interfaceMode_Move) {
      interface_Move_mouseDragged(e);
    }

    if (flagInterfaceMode == interfaceMode_Zoom) {
      interface_Zoom_mouseDragged(e);
    }


  }


 public void interface_Move_mouseDragged(MouseEvent e) {

    String    modifierStr;
    int       modifier;
    int       flagMode;

    modifier    = e.getModifiersEx();
    modifierStr = e.getModifiersExText(modifier);

    /* determine the mode */
    flagMode = -1;
    if (("Button1".equals(modifierStr)) && (flagMode == -1)) {
      int dirFlag = 1;
      interface_Move_VRP_mouseDragged(e, dirFlag); /* second is flag for dir */
    }

    if (("Shift+Button1".equals(modifierStr)) && (flagMode == -1)) {
      int dirFlag = 2;
      interface_Move_VRP_mouseDragged(e, dirFlag); /* second is flag for dir */
    }

    eventOutput("Mouse dragged: modifierStr = " + modifierStr + "; flagMode = " + flagMode + "; ", e);

  }


  public void interface_Move_VRP_mouseDragged(MouseEvent e, int dirFlag) {

    double    xDiff;
    double    yDiff;
    String    modifierStr;
    int       modifier;
    long      timeElapsed;
    Dimension size = getRenderScreenSize();
    int       w    = size.width;
    int       h    = size.height;
    int       num_dim          = 3;
    int       flagMode;
    int       i,j,k,d;

    if (flagMouseDraggedOn == 0) {

      camera_on_click = camera.clone();
      
      mousePositionOnClickX = e.getX();
      mousePositionOnClickY = e.getY();

      mouseClickedElaspedTime_last = System.currentTimeMillis();

      flagMouseDraggedOn = 1;
    } else {

      mouseClickedElaspedTime = System.currentTimeMillis();

      timeElapsed = mouseClickedElaspedTime - mouseClickedElaspedTime_last;

      if (timeElapsed > 0) {

        mouseClickedPositionX = e.getX();
        mouseClickedPositionY = e.getY();

        /* figure out the mode */

        /* if rotation of object */
        xDiff = mouseClickedPositionX - mousePositionOnClickX;
        yDiff = mouseClickedPositionY - mousePositionOnClickY;

        /* figure out directions in world coordinates in which to move based on
         * the current camera location and view.
         */

        double cameraR[];
        double cameraR_T[];

        double moveVec[] = new double[num_dim];
        double moveVec_p[];

        /* determine displacement in camera coordinates */
          moveVec[0] = 0;
          moveVec[1] = 0;
          moveVec[2] = 0;

        if (dirFlag == 1) { /* left right movement */
          moveVec[0] = (-xDiff/w)*camera_on_click.cameraWinBounds[0];
          moveVec[1] = (-yDiff/h)*camera_on_click.cameraWinBounds[1];
          moveVec[2] = 0;
        }

        if (dirFlag == 2) { /* in and out movement */
          moveVec[0] = 0;
          moveVec[1] = (-yDiff/h)*camera_on_click.cameraWinBounds[1];
          moveVec[2] = (-xDiff/w)*camera_on_click.cameraWinBounds[0];
        }

        /* get the rotation matrices used to go from world to camera coordinates */
        cameraR   = camera_on_click.genCameraRotationMatrix();               /* world --> camera coord. */
        cameraR_T = cameraR.clone();
        Atz_LinearAlgebra.matrixTranspose(num_dim, num_dim, cameraR, cameraR_T); /* camera coord. --> world */

        moveVec_p = moveVec.clone();
        Atz_LinearAlgebra.matrixVecMult(num_dim, num_dim, cameraR_T,
                                    moveVec, moveVec_p);

        /* apply the displacement to change the camera reference point (location) */
        for (d = 0; d < num_dim; d++) {
          camera.cameraVRP[d] = camera_on_click.cameraVRP[d] + moveVec_p[d];
        }

        /*
        if (controlPtsSelectedList.length != 0) {
          k = controlPtsSelectedList[0];
          for (d = 0; d < num_dim; d++) {
            controlPts_X_ref[k*num_dim + d] = controlPts_X_ref_on_click[k*num_dim + d] - moveVec_p[d];
          }
        }
         */

        eventOutput("Mouse dragged xDiff = " + xDiff
                  + "; yDiff = " + yDiff
                  + "; E_time = " + timeElapsed,
                  e);

        //jPanel_Display.repaint();
        repaint();
      }

      mouseClickedPositionX_last   = mouseClickedPositionX;
      mouseClickedPositionY_last   = mouseClickedPositionY;

      mouseClickedElaspedTime_last = mouseClickedElaspedTime;

    } /* end else */

  }


  public void interface_Zoom_mouseDragged(MouseEvent e) {

    String    modifierStr;
    int       modifier;
    int       flagMode;

    modifier    = e.getModifiersEx();
    modifierStr = e.getModifiersExText(modifier);

    /* determine the mode */
    flagMode = -1;
    if (("Button1".equals(modifierStr)) && (flagMode == -1)) {
      int dirFlag = 1;
      interface_Zoom_VRP_mouseDragged(e, dirFlag); /* second is flag for dir */
    }

    eventOutput("Mouse dragged: modifierStr = " + modifierStr + "; flagMode = " + flagMode + "; ", e);

  }

  public void interface_Zoom_VRP_mouseDragged(MouseEvent e, int dirFlag) {

    double    xDiff;
    double    yDiff;
    String    modifierStr;
    int       modifier;
    long      timeElapsed;
    Dimension size = getRenderScreenSize();
    int       w    = size.width;
    int       h    = size.height;
    int       num_dim          = 3;
    int       flagMode;
    int       i,j,k,d;

    if (flagMouseDraggedOn == 0) {

      camera_on_click = camera.clone();
      
      mousePositionOnClickX = e.getX();
      mousePositionOnClickY = e.getY();

      mouseClickedElaspedTime_last = System.currentTimeMillis();

      flagMouseDraggedOn = 1;
    } else {

      mouseClickedElaspedTime = System.currentTimeMillis();

      timeElapsed = mouseClickedElaspedTime - mouseClickedElaspedTime_last;

      if (timeElapsed > 0) {

        mouseClickedPositionX = e.getX();
        mouseClickedPositionY = e.getY();

        /* figure out the mode */

        /* if rotation of object */
        xDiff = mouseClickedPositionX - mousePositionOnClickX;
        yDiff = mouseClickedPositionY - mousePositionOnClickY;

        /* figure out directions in world coordinates in which to move based on
         * the current camera location and view.
         */

        double cameraR[];
        double cameraR_T[];

        double moveVec[] = new double[num_dim];
        double moveVec_p[];

        /* determine displacement in camera coordinates */
          moveVec[0] = 0;
          moveVec[1] = 0;
          moveVec[2] = 0;

        if (dirFlag == 1) { /* left right movement */
          moveVec[0] = (-xDiff/w)*camera_on_click.cameraWinBounds[0];
          moveVec[1] = (-yDiff/h)*camera_on_click.cameraWinBounds[1];
          moveVec[2] = 0;
        }

        if (dirFlag == 2) { /* in and out movement */
          moveVec[0] = 0;
          moveVec[1] = (-yDiff/h)*camera_on_click.cameraWinBounds[1];
          moveVec[2] = (-xDiff/w)*camera_on_click.cameraWinBounds[0];
        }

        /* get the rotation matrices used to go from world to camera coordinates */
        double scaleFactor = 1.0;
        double dist    = java.lang.Math.sqrt(moveVec[0]*moveVec[0] + moveVec[1]*moveVec[1]);
        if (moveVec[0] < 0) { /* left (shrink) / right (grow) */
          scaleFactor = 1 / (1 - 3*moveVec[0]);
        } else { /* moveVec[0] < 0 */
          scaleFactor = 1 + 3*moveVec[0];
        }

        interface_Scale_CameraWindow(scaleFactor, camera_on_click);

        eventOutput("Mouse zoom dragged xDiff = " + xDiff
                  + "; yDiff = " + yDiff
                  + "; E_time = " + timeElapsed,
                  e);

        //jPanel_Display.repaint();
        repaint();
      }

      mouseClickedPositionX_last   = mouseClickedPositionX;
      mouseClickedPositionY_last   = mouseClickedPositionY;

      mouseClickedElaspedTime_last = mouseClickedElaspedTime;

    } /* end else */

  }




  public void interface_Navigation_mouseDragged(MouseEvent e) {

    String    modifierStr;
    int       modifier;
    int       flagMode;

    modifier    = e.getModifiersEx();
    modifierStr = e.getModifiersExText(modifier);

    /* determine the mode */
    flagMode = -1;
    if (("Button1".equals(modifierStr)) && (flagMode == -1)) {
      flagMode = 1; /* rotation mode */
      interface_Navigation_rotation_mouseDragged(e);
    }

    eventOutput("Mouse dragged: modifierStr = " + modifierStr + "; flagMode = " + flagMode + "; ", e);

  }


  public void interface_Navigation_rotation_mouseDragged(MouseEvent e) {

    double    xDiff;
    double    yDiff;
    String    modifierStr;
    int       modifier;
    long      timeElapsed;
    Dimension size = getRenderScreenSize();
    int       w    = size.width;
    int       h    = size.height;

    int    num_dim          = 3;
    double rotationMatrix[] = new double[num_dim * num_dim];
    double vec_theta[]      = new double[num_dim];

    double tmp_vec1[]       = new double[num_dim];
    double tmp_vec2[] = new double[num_dim];

    double[] vec_theta_p;
    double[] cameraR;
    double[] cameraR_T;

    int    flagMode;

    if (flagMouseDraggedOn == 0) {

      camera_on_click = camera.clone();

      mousePositionOnClickX = e.getX();
      mousePositionOnClickY = e.getY();

      mouseClickedElaspedTime_last = System.currentTimeMillis();

      flagMouseDraggedOn = 1;

    } else {

      mouseClickedElaspedTime = System.currentTimeMillis();

      timeElapsed = mouseClickedElaspedTime - mouseClickedElaspedTime_last;

      if (timeElapsed > 0) {

        mouseClickedPositionX = e.getX();
        mouseClickedPositionY = e.getY();

        /* figure out the mode */

        /* if rotation of object */
        xDiff = mouseClickedPositionX - mousePositionOnClickX;
        yDiff = mouseClickedPositionY - mousePositionOnClickY;

        /* generate x and y rotations */
        double tmpMatrix[] = new double[9];

        /* rotation vector in the camera coordinate frame */
        vec_theta[0] = -yDiff * (2 * java.lang.Math.PI / w);
        vec_theta[1] = xDiff * (2 * java.lang.Math.PI / h);
        vec_theta[2] = 0;

        /* convert rotation vector to the world coordinate frame */
        cameraR   = camera_on_click.genCameraRotationMatrix(); /* world --> camera coord. */
        cameraR_T = cameraR.clone(); /* camera coord. --> world */

        Atz_LinearAlgebra.matrixTranspose(num_dim, num_dim, cameraR, cameraR_T);

        vec_theta_p = vec_theta.clone();
        Atz_LinearAlgebra.matrixVecMult(num_dim, num_dim, cameraR_T,
                                        vec_theta, vec_theta_p);
        
        /* generate the rotation matrix based on vec_theta_p */
        Atz_LinearAlgebra.genRotationMatrix(vec_theta_p, rotationMatrix);
        
        /* apply the rotation to change the camera view direction */
        Atz_LinearAlgebra.matrixVecMult(num_dim, num_dim, rotationMatrix,
                                    camera_on_click.cameraVPN, camera.cameraVPN);
        Atz_LinearAlgebra.matrixVecMult(num_dim, num_dim, rotationMatrix,
                                    camera_on_click.cameraVUP, camera.cameraVUP);

        eventOutput("Mouse dragged xDiff = " + xDiff
          + "; yDiff = " + yDiff
          + "; vec_theta[2] = " + vec_theta[2]
          + "; E_time = " + timeElapsed,
          e);

        //jPanel_Display.repaint();
        repaint();
      }

      /*
      mouseClickedPositionX_last   = mouseClickedPositionX;
      mouseClickedPositionY_last   = mouseClickedPositionY;
       */

      mouseClickedElaspedTime_last = mouseClickedElaspedTime;

    } /* end else */

  } /* end of mouseDragged */


  public void mouseWheelMoved(MouseWheelEvent e) {

    String message;
    int notches = e.getWheelRotation();

    if (notches < 0) {
      message = "Mouse wheel moved UP "
              + -notches + " notch(es)";
    } else {
      message = "Mouse wheel moved DOWN "
              + notches + " notch(es)";
    }
    if (e.getScrollType() == MouseWheelEvent.WHEEL_UNIT_SCROLL) {
      message += "    Scroll type: WHEEL_UNIT_SCROLL";
      message += "    Scroll amount: " + e.getScrollAmount()
              + " unit increments per notch";
      message += "    Units to scroll: " + e.getUnitsToScroll()
              + " unit increments";
      message += "    Vertical unit increment: "
              + " pixels";
    } else { //scroll type == MouseWheelEvent.WHEEL_BLOCK_SCROLL
      message += "    Scroll type: WHEEL_BLOCK_SCROLL";
      message += "    Vertical block increment: "
              + " pixels";
    }
    eventOutput(message, e);


    int    scrollAmount;
    int    unitsToScroll;
    double scaleFactor;

    scrollAmount  = e.getScrollAmount();
    unitsToScroll = e.getUnitsToScroll();

    if (notches < 0) {
      scaleFactor  = 1.1;
    } else {
      scaleFactor  = 0.9;
    }
    interface_Scale_CameraWindow(scaleFactor);

  }

  public void interface_Scale_CameraWindow(double scaleFactor, Atz3D_Camera baseCamera) {

    /* use the scroll wheel to effect the zoom factor */
    int    num_dim       = 3;
    double scaleMatrix[] = new double[num_dim * num_dim];
    double tmpMatrix[]   = new double[num_dim * num_dim];

    scaleMatrix[0] = scaleFactor;
    scaleMatrix[1] = 0;

    scaleMatrix[2] = 0;
    scaleMatrix[3] = scaleFactor;

    //Atz3D_Camera tmpCamera = camera.clone();
    Atz_LinearAlgebra.matrixVecMult(num_dim - 1, num_dim - 1, scaleMatrix,
                                    baseCamera.cameraWinBounds, camera.cameraWinBounds);

    //jPanel_Display.repaint();
    repaint();

  }  /* end of paint */


  public void interface_Scale_CameraWindow(double scaleFactor) {

    Atz3D_Camera tmpCamera = camera.clone();

    interface_Scale_CameraWindow(scaleFactor, tmpCamera);

  }  /* end of paint */


  public void renderViewsToModel3D(Atz3D_Model model3D) {
    int k;

    for (k = 0; k < renderViewList.length; k++) {
      renderViewList[k].renderToModel3D(model3D);
    }

  }

  public void addRenderView(SELM_RenderView renderViewToAdd) {

    int k;
    int N;

    N = renderViewList.length;

    SELM_RenderView[] renderViewList_new
      = new SELM_RenderView[N + 1];

    for (k = 0; k < N; k++) {
      renderViewList_new[k] = renderViewList[k];
    }

    renderViewList_new[N] = renderViewToAdd;

    renderViewList = renderViewList_new;

  }


  public void removeAllRenderView() {
    renderViewList = new SELM_RenderView[0];
  }

  public void removeAllRenderView(String tag) {

    /* identify number of entries having a given tag */
    int N = renderViewList.length;
    int count = 0;
    boolean[] mask = new boolean[N];
    for (int k = 0; k < N; k++) {
      mask[k] = (renderViewList[k]).getRenderTag().equals(tag);
      if (mask[k] == false) {
        count++;
      } else {
        /* do nothing */
      }
    }

    /* create a new list with only entries not having the tag */
    int numNewList = count;
    SELM_RenderView[] renderViewList_new = new SELM_RenderView[numNewList];
    int I = 0;
    for (int k = 0; k < N; k++) {

      if (mask[k] == false) {
        renderViewList_new[I] = renderViewList[k];
        I++;
      } else {
        /* do nothing */
      }

    }

    renderViewList = renderViewList_new;

  }

  public void setBackgroundColor(Color bk1, Color bk2) {
    backgroundColor1 = bk1;
    backgroundColor2 = bk2;
  }


  @Override
  public Dimension getSize() {
    return getRenderScreenSize();
  }

  @Override
  public void setSize(Dimension size) {

    Dimension sizeNew = new Dimension();

    int minDim = java.lang.Math.min(size.width,size.height);

    sizeNew.width  = minDim;
    sizeNew.height = minDim;

    super.setSize(sizeNew);

  }

  @Override
  public int getWidth() {
    return getRenderScreenWidth();
  }

  @Override
  public int getHeight() {
    return getRenderScreenHeight();
  }

  public Dimension getRenderScreenSize() {
    Dimension size = super.getSize();

    int minDim = java.lang.Math.min(size.width,size.height);

    size.width  = minDim;
    size.height = minDim;

    return size;
  }

  public int getRenderScreenWidth() {
    Dimension size = getRenderScreenSize();

    return size.width;
  }

  public int getRenderScreenHeight() {
    Dimension size = getRenderScreenSize();

    return size.height;
  }

  public int[] getRenderScreenCenterX0() {
    Dimension fullSize = super.getSize();
    int[]     X0       = new int[2];

    int minDim  = java.lang.Math.min(fullSize.width,fullSize.height);

    X0[0]       = fullSize.width/2;
    X0[1]       = fullSize.height/2;

    return X0;
  }

  public void setRenderBackgroundColors(Color bk1, Color bk2) {
    backgroundColor1 = bk1;
    backgroundColor2 = bk2;

    this.repaint();
  }

  public void setAxisInfo(boolean flagVisible, String[] axisLabels_in, Color axisColor_in, Color axisLabelColor_in) {

    if (atz3D_Renderer_SELM != null) {
      atz3D_Renderer_SELM.setAxisInfo(flagVisible, axisLabels_in, axisColor_in, axisLabelColor_in);
    }
    
  }





}
